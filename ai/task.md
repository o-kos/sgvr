# Визуализация спектра из файла

## 1. Постановка задачи

1. Есть wav файл с сигналом, возможно, очень большого размера.
2. Надо сформировать его спектрограмму, по горизонтальной оси - время, по вертикальной - частота. Обе оси - линейные. Яркость пикселя в каждой точке там выше, чем больше значение амплитуды, соответствующей частоте в этот момент времени.
3. Надо сделать так, чтобы она выглядела наиболее адекватно в окне дисплея вне зависимости от ширины самого окна. И чтобы скорость ее формирования была при этом максимальной.
4. Формирование спектра должно быть двухэтапным - максимально быстрое для отображения
'эксизного' варианта и далее фоновая подготовка данных с качественным вариантом спектра
для целевого изображения. При этом целевые данные должны отдаваться для отображения по мере их готовности.

## 2. Способ решения

Решение можно разбить на два больших независимых этапа: **подготовка данных** (медленная часть, делается один раз) и **отображение** (быстрая часть, делается при каждом изменении размера окна).

Вот предлагаемый способ решения, который отвечает всем вашим требованиям.

### Основная идея

Ключевая мысль — **отделить вычисление спектрограммы от её отображения**. Мы не будем генерировать картинку под конкретный размер окна каждый раз заново. Вместо этого мы один раз вычислим "полноразмерную" спектрограмму в виде числовых данных, а затем будем очень быстро формировать из этих данных изображение нужного размера.

---

### Этап 1: Подготовка данных (вычисление "мастер-спектрограммы")

Этот этап выполняется один раз для файла и является самым вычислительно дорогим. Его цель — получить двумерный массив данных `[время][частота] = значение_амплитуды`.

1.1.  **Выбор параметров STFT (Short-Time Fourier Transform):**
    *   **Размер окна (FFT size, N_FFT):** Определяет разрешение по частоте. Чем больше значение (например, 2048, 4096), тем детальнее будет вертикальная ось (частоты), но хуже разрешение по времени. `2048` — хороший старт.
    *   **Шаг окна (Hop length):** Определяет разрешение по времени. Это количество сэмплов, на которое окно сдвигается на каждом шаге. Обычно берут `N_FFT / 4` или `N_FFT / 8`. Чем меньше шаг, тем больше "столбцов" (временных отсчетов) будет у нашей спектрограммы, и тем она будет детальнее по горизонтали.
    *   **Оконная функция (Window function):** Например, функция Ханна (Hann) или Хэмминга (Hamming). Она нужна, чтобы сгладить края блоков данных и уменьшить "спектральные утечки", делая спектр более чистым.

1.2.  **Потоковая обработка WAV файла:**
    *   **Не загружать весь файл в память!** Это критически важно для больших файлов.
    *   Читайте файл по частям (чанками), например, по 1-4 мегабайта.
    *   Двигайтесь по аудиоданным с выбранным шагом (`hop_length`), на каждом шаге вырезая блок размером `N_FFT`. Эти блоки будут перекрываться (overlap).

1.3. **Быстрый результат в виде эскиза для preview**
    *   Для того, чтобы быстро отдать пользователю результат в виде эскиза, нужно сделать ровно столько независимых выборок для эскизной спектрограммы, сколько нужно для отображения на экране. Обсчитать для них данные, вернуть пользователю и затем уже заняться более длительными расчетами для получения качественной спектрограммы.

1.4.  **Вычисление спектра для каждого блока:**
    *   К каждому вырезанному блоку примените оконную функцию.
    *   Выполните быстрое преобразование Фурье (FFT).
    *   Результат FFT — комплексные числа. Нас интересует только их **амплитуда (модуль)**.
    *   Так как исходный сигнал реальный, спектр будет симметричным. Нам нужна только первая половина результатов (`N_FFT / 2 + 1` значений).

1.5.  **Логарифмическое масштабирование амплитуды:**
    *   Человеческий слух и зрение воспринимают яркость и громкость логарифмически. Чтобы спектрограмма была информативной (чтобы тихие звуки не потерялись на фоне громких), переведите амплитуды в децибелы (dB): `20 * log10(amplitude)`.
    *   Результат этого шага — один "столбец" нашей будущей спектрограммы.

1.6.  **Сохранение результата:**
    *   Все полученные "столбцы" (массивы амплитуд в dB для каждого временного шага) сохраняются последовательно. Это и есть наша **"мастер-спектрограмма"** — большой двумерный массив чисел. Его можно временно хранить на диске или в памяти, если она позволяет.

На выходе этого этапа мы имеем `N` временных отсчетов, для каждого из которых есть `M` частотных бинов (`M = N_FFT / 2 + 1`). `N` может быть очень большим (миллионы).

---

### Этап 2: Адаптивное отображение (быстрая визуализация)

Этот этап выполняется каждый раз, когда нужно отрисовать спектрограмму в окне шириной `W` пикселей и высотой `H` пикселей. Он должен быть максимально быстрым.

Предположим, наша мастер-спектрограмма имеет размер `N` столбцов на `M` строк.

2.1.  **Горизонтальное масштабирование (ось времени):**
    *   Это самая важная часть для "адекватного" вида. Мы должны отобразить `N` столбцов данных в `W` пиксельных столбцах окна.

    *   **Случай 1: Сильное сжатие (`W < N`)** — самый частый случай для больших файлов.
        *   Один пиксельный столбец на экране представляет собой группу из нескольких (`N / W`) столбцов из мастер-спектрограммы.
        *   **Нельзя просто брать среднее!** Если усреднить значения, то короткие, но громкие звуки (например, щелчок, удар барабана) "размажутся" и станут невидимыми.
        *   **Правильный подход:** для каждого пиксельного столбца `x` (от 0 до `W-1`) мы определяем диапазон столбцов в мастер-данных, которые он покрывает (например, с `i`-го по `j`-й). Затем для каждой частоты (каждой строки `y` от 0 до `M-1`) мы находим **максимальное** значение амплитуды среди всех столбцов с `i` по `j`.
        *   `PixelColumn[y] = max(MasterData[y][i...j])`
        *   Этот метод гарантирует, что пики и важные события не будут потеряны при масштабировании. Спектрограмма будет выглядеть сжатой, но все еще информативной.

    *   **Случай 2: Растяжение (`W > N`)** — если окно очень широкое, а файл короткий.
        *   Несколько пиксельных столбцов на экране будут отображать один и тот же столбец данных.
        *   Самый простой и быстрый способ — просто дублировать столбец данных для всех соответствующих пикселей (интерполяция по ближайшему соседу).

2.2.  **Вертикальное масштабирование (ось частот):**
    *   Здесь все проще. У нас есть `M` частотных бинов, которые нужно отобразить в `H` пикселях по вертикали.
    *   Можно использовать простую линейную интерполяцию или интерполяцию по ближайшему соседу, чтобы для каждой пиксельной строки `y` найти соответствующее значение из агрегированного столбца, полученного на шаге 1.

2.3.  **Преобразование в цвет (Colormapping):**
    *   На этом шаге у нас есть готовый двумерный массив чисел размером `W x H`, где каждое число — это значение амплитуды в dB.
    *   Определите палитру (colormap), например: от черного (минимальный dB, тишина) через синий, зеленый к желтому (максимальный dB, громко).
    *   Преобразуйте каждое числовое значение в соответствующий цвет из палитры.
    *   Полученный массив пикселей можно выводить на экран.

### Оптимизация для максимальной скорости

*   **Мипмэпы (MIP-maps):** Чтобы еще больше ускорить этап отображения, можно заранее просчитать несколько уровней детализации (LODs) для мастер-спектрограммы. Например, создать уменьшенные в 2, 4, 8, 16... раз по горизонтали версии, используя тот же принцип нахождения максимума. Тогда при рендеринге можно будет взять наиболее подходящий по размеру готовый LOD и масштабировать уже его, что сократит количество вычислений.
*   **Параллельные вычисления:** Этап 1 (подготовка данных) отлично параллелится. Можно обрабатывать разные части аудиофайла в разных потоках.

### Итог

Этот двухэтапный подход решает все поставленные задачи:
1.  **Работа с большими файлами:** За счет потоковой обработки.
2.  **Адекватное отображение:** За счет агрегации по максимуму, а не по среднему, что сохраняет важные детали сигнала при любом масштабе.
3.  **Максимальная скорость:** Дорогое вычисление делается один раз. Перерисовка при изменении размера окна — это очень быстрая операция агрегации и масштабирования уже готовых данных, которая легко укладывается в реальное время.

---

## 3. План действий

Решать задачу будем в следующем порядке:

3.1. Создаем консольное приложение на `rust`, которое будет состоять из 3х файлов:
    *   `main.rs` — содержит главную программу, которая будет обрабатывать параметры
    командной строки, вызывать функции из библиотек и отображать прогресс исполнения в терминале.
    *   `scalc.rs` — содержит функции для работы с файлами и расчета спектральных данных.
    *   `sview.rs` — содержит функции для формирования изображений спектра и сохранения их в файле.

Приложение должно уметь обрабатывать следующие аргументы командной строки:

Параметры:
-f или --fft-size       - размерность FFT (по умолчанию - 2048)
-w или --window-type    - тип оконной функции (`hann` или `hamming`, по умолчанию - `hann`)
-i или --image-size     - размер целевого изображения в пикселях в формате WxH (по умолчанию - `2048х512`)
-с или --color-scheme   - используемая цветовая схема (`navy`, `gray`, `bloody`, по умолчанию - `Navy`)
Флаги:
-p     --preview-save   - сохранять предварительный эскиз спектра (по умолчанию - `true`)
-h     --help           - отобразить описание параметров
-v     --version        - вывести номер версии и дату сборки
Последовательный аргумент:
fileName                - имя файла с сигналом

3.2. Пишем тесты ко всем файлам, убеждаемся, что всё работает правильно и производим замеры производительности.

3.3. Модифицируем приложение так, чтобы `scalc.rs` можно было без изменений использовать в backend `tauri`, а все вызовы функций из `main.rs` были асинхронными.

3.4. Снова пишем тесты и проверяем производительность всего решения.

3.5. Делаем `tauri` приложение и подключаем к нему функции из `scalc.rs`.
